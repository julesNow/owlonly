#
# udp_capture_socket.py
#
# UDP socket handlers for streaming audio capture.
#
# UDP is necessary for some LTE-M boards, such as the Spresense, where bandwidth is limited.
#

import asyncio
import uuid
from .app_state import AppState
from .streaming_capture_handler import StreamingCaptureHandler
import logging

logger = logging.getLogger(__name__)

class UDPCaptureSocketApp(asyncio.DatagramProtocol):
    def __init__(self, app_state: AppState, timeout_seconds=5):
        self._app_state = app_state
        self._transport = None
        self._capture_uuid = None
        self._timeout_seconds = timeout_seconds
        self._timeout_handle = None

    def connection_made(self, transport: asyncio.DatagramTransport) -> None:
        self._transport = transport
        # Create a new capture session with id generated by the server since we don't have a UPD protocol for this
        self._capture_uuid = uuid.uuid1().hex
        self._app_state.capture_handlers[self._capture_uuid] = StreamingCaptureHandler(
            self._app_state, "spresense", self._capture_uuid, "mp3"
        )

    def datagram_received(self, data: bytes, addr):
        if self._timeout_handle:
            self._timeout_handle.cancel() 
        self._timeout_handle = asyncio.get_running_loop().call_later(
            self._timeout_seconds, self.connection_timed_out)
        
        asyncio.create_task(self.send_info_to_client(data))

    async def send_info_to_client(self, data: bytes):
        await self._app_state.capture_handlers[self._capture_uuid].handle_audio_data(data)

    def connection_timed_out(self):
        if self._capture_uuid not in self._app_state.capture_handlers:
            logger.error(f"Capture session not found: {self._capture_uuid}")
            return
        capture_handler = self._app_state.capture_handlers[self._capture_uuid]
        capture_handler.finish_capture_session()
